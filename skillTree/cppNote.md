> for C++ Primer 5
# Part 1
## Chap 1 ~ 7
### chap1
1. iostream cin cout cerr clog (p5
- cin >> v1;
- cout << v1;
- std::endl 操纵符，结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。

2. 读入数量不定的数据 (p13
- while(std::cin >> value)
- 持续获取直到遇到文件结束符或出错

3. include指令  （p19
- 包含标准库时使用 < >
- 包含其他库使用 “ ”

4. 文件重定向  （p19
- __blank__

### chap2
- python, smalltalk 运行时检查数据类型 （动态
- c++编译时检查数据类型 （静态数据类型语言

1. 内置类型选择 （p32
- 明确知道不为负，使用unsigned；
- 超过int 选long long
- 算数表达式尽量不选用char或bool
- 浮点运算选用double

2. 类型转换 （p35
- 切勿混用 带符号类型 与 无符号类型

3. 字面值常量 （p35
- 20 十进制
- 024 八进制
- 0x14 十六进制

4. 转义字符 与 指定字面值类型 （p37

5. __列表初始化__ （p39
- 使用花括号来赋初始值
- 使用这种方法时，当存在丢失信息风险会报错

6. 声明与定义的关系
- 分离式编译：将程序分割为多个文件，每个文件可以被独立编译

- 声明：使得 名字 为程序所知
- extern int i;  
- 一旦显示初始化，声明即为定义： 
- extern double pi = 3.1416;
- 函数体内部，不能初始化一个extern关键字的变量 （发生重复定义

- 定义：创建与名字关联的实体
- int j;

7. 标识符 （p42
- 必须以字母或下划线开头
- 不能连续两个下划线，不能下划线+大写字母开头，函数体外标识符不能以下划线开头；

- 规范
- 变量用小写
- 自定义类名用大写开头
- 匈牙利命名法

8. 作用域
- { }花括号
- 作用域嵌套：内层作用域里可使用同名局部变量覆盖全局变量（不推荐

9. 复合类型 （p45
- 基于其他类型的定义的类型（指针与引用） 基本数据类型 + 声明符列表， 每个声明符命名变量并指定相关类型

 9.1. __引用__（左值引用）
 - int &ref = val;  //引用即别名
 - 引用本身不是对象， 不能定义引用的引用
 
 9.2. __指针__
 - 指针是一个对象，允许赋值与拷贝，
 - 指针类型要匹配
 - 预处理器（p49） NULL是预处理变量
 - _void *指针_ ：可用于存放任意对象的值，存放一个地址，但不能直接操作所指对象。
 
 9.3. _指向指针的指针 指向指针的引用_
 - int **ppi = &pi;
 - int i = 43;
 - int *p;
 - int *&r = p;  //r是一个对指针p的引用！
 - __注意！要理解r的类型，从右向左阅读r的定义。离变量名最近的符号对变量名有最直接的影响：&---r是一个引用，*---r引用的是指针，int---r引用的是int类型的指针。__
 
10. const限定符
- 为了防止对变量的更改。
- __必须初始化__   默认状态下，const对象仅在文件内有效，想在文件之间共享const对象，必须在前面添加extern关键字
 10.1. const的引用（常量引用）
 - const int ci = 1024;
 - const int &r1 = ci;  //保持常量的属性：不许赋值
 
 __初始化与const的引用（p55__
 - int i = 42;
 - const int &r1 = i; //正确的，常量引用可以绑定普通对象
 - __const int &r2 = 42 //正确的，可以绑定字面常量！！！！但是普通的引用不可以绑定字面常量__
 - __const int &r3 = r1 * 2; //正确的，可以绑定一般表达式！！！__
 
 - __常量引用的绑定原理__
 - 当发现绑定需要进行类型转换时，编译器生成临时量，让常量引用绑定 __临时量对象__ 。
 
 10.2 指针与const
 - 指向常量的指针：（pointer to const）
 - const double pi = 3.1416;  //const pi
 - const double *cptr = &pi; //指向常量的指针cptr，不允许通过此指针修改常量的值，也可以指向非常量对象
 
 - const指针(常量指针)，指针本身是常量，指针本身的值不变，指向不改变
 - int errNumb = 0;
 - int *const curErr = & errNumb; //curErr将一直指向errNumb
 - __技巧，从右向左阅读，离得最近的是const---本身是常量对象，*---是一个常量指针，int---指向int对象__
 
 10.3. 顶层 const
 - 顶层const： 指针本身是常量， 或任意对象是常量
 - 底层const： 指针对象是常量
 - const int &r = ci; //用于声明引用的const都是底层const
 
 10.4. constexpr 常量表达式
 - 值不会改变，在编译过程中就能得到计算结果的表达式。
 - const int i = 20;  //const val
 - const int constexp = i + 1; //const expr 用常量初始化的const对象
 - const int sz = get_size();  //不是常量表达式，只有在运行时才能知道结果
 - __constexpr变量__
 - 将变量声明为constexpr来验证变量的值是否为常量表达式 1）变量一定是常量 2）必须用常量初始化（或使用constexpr函数初始化）
 - （p59）字面值常量
 - constexpr int *q = nullptr;  //q是常量指针！ constexpr是顶层const 指向不改变（p60）
 
 11. 处理类型
 - typedef double wages; //wages 是 double的同义词
 - typedef wages base, *p; //base 是double的同义词， p是double*的同义词
 
 - using SI = Sales_item; //SI是Sales_item的同义词
 -__(p61) 别名指代复合类型，特别注意__
 
 - auto类型声明 
 - 一条语句只能有一个数据类型
 - const保留的性质（p62）
 - decltype 类型指示符，编译器分析类型，并不实际调用（p62）
 - decltype(f()) sum = x;   
 - __decltype()对引用的返回值记得带上引用__ (p63) 解引用操作得到引用类型，双层括号得到引用
 
 12. struct
 - struct定义最后加上分号，因为类体后面可以紧跟变量名定义对象
 
 - 一般在头文件中定义类，不要在函数体里定义类
 - 头文件中包含只能被定义一次的实体：类  const  constexpr等
 - 使用头文件保护符防止重复包含：
 - #ifndef XXX_XXX
 - #define XXX_XXX     <-预处理变量 大写 唯一
 - /*..........*/
 - #endif
 
 ###chap3
 1.using
 - using std::cin;  //using声明，可以直接使用名字cin
 - 头文件中的代码一般不适用using，重复拷贝后，可能产生名字冲突
 
 2. string
 - #include <string>
 - using std::string;
 
 - string s4(n, 'c'); //s4初始化为连续n个c的字符串
 - 直接初始化和拷贝初始化（用“=”）
 
 - 操作
 - getline(is, s) //从is中读一行赋给s
 - s[1] + s[2] //连接
 - <, <=, >, >= //利用字典顺序比较，大小写敏感
 
 - string::size_type //size()方法返回类型，无符号整型（p79）
 
 - 字面值与string相加，不能两个字面值相加
 
 - 字符处理 cctype头文件（p82）
 
 - __基于范围的for语句__
 - for(atuo c : str){ /*....*/ } //c的类型是char
 - for(auto &c : s){ /*....*/ } //这里是引用，会改变s中字符的值
 
 3. vector
 - 容器（part2）
 - #include <vector>
 - using std::vector;
 
 - 类模板，实例化
 
 - 定义和初始化：（p87）
 - vector<T> v2(v1)； //拷贝v1的元素给v2
 - vector<T> v3(n, val); //
 - vector<T> v4(n); //
 - vector<T> v5{a, b, c...}; //(p89) 列表初始化 提供的值不能作为元素初始值时，尝试默认初始化
 
 - vector操作（p91）
 4. 迭代器（iterator）
 - 类似指针，提供对对象的间接访问，分为有效无效，有效迭代器指向某个元素或指向尾元素的下一位置；其他是无效。
 
 - auto b = v.begin(), e = v.end(); //b,e类型相同
 - begin成员返回指向第一个元素的迭代器，end成员返回指向容器“尾元素下一位置”的迭代器（“尾后元素“），标记表示已经处理完了容器中的所有元素（尾后迭代器），当容器为空，b和e返回同一个迭代器。
 
 - 迭代器操作（p96）
 - *iter, iter->mem, ++iter, --iter
 - 迭代器运算符==，!=判断迭代器是否相等
 
 - 迭代器类型 分为 iterator和const_iterator，类似指针和常量指针；
 - cbegin(),cend()
 - __箭头运算符”->“也可以访问成员函数__（解引用+成员访问）
 - 迭代器失效！使用迭代器的循环体不要向容器中添加元素！
 
 - 迭代器运算（p99）
 - iter + n, iter += n, iter1 - iter2, <=
 
 5. 数组
 - __编译时维度必须已知，必须是常量表达式（constexpr）__
 - 字符数组初始化时，需要考虑'\0'的位置，使用字符串初始化字符数组，会自动添加\0,列表初始化需要手动添加。
 
 - __复杂的数组声明__
 - int *ptrs[10]; //ptrs是含有10个整形指针的数组
 - int &refs[10]; //错误！不存在引用的数组
 - int (*Parray)[10]; //Parray指向一个含有10个整数的数组
 - int (&arrRef)[10]; //引用一个含有10个元素的数组
 - 从数组名字开始 由内向外阅读
 
 - （p105）auto 和 decltype使用数组名作为参数的情况
 
 - 获取尾后指针可以暂时越界访问数组，更应该使用c++11的begin和end函数
 
 - （p108）下标和指针的转换
 
 - c风格字符串（字符数组+\0结尾，利用指针操作）
 - c标准库string函数（p109）
 
 - （p111）使用string对象初始化指向字符数组的指针 c_str()方法
 - 使用数组初始化vector（使用begin和end）
 
 ###chap4
 1. 表达式基础
 - 运算对象提升（p141）
 - 左值右值：用对象的值（内容）——右值，用对象的身份（内存中的位置）——左值
 - 需要右值的地方可以用左值代替，但是不能用右值当成左值。
 - 需要左值：
 - 赋值运算符，左侧左值，得到左值
 - 取值运算符，作用于左值，返回一个指向其的指针，此指针是右值
 - 解引用，下标运算符，求值结果为左值
 - __递增递减运算符，作用于左值，前置版本得到左值__
 - decltype()中的表达式求值是左值，得到引用类型，是右值得到指针（p121）
 
 - 求值顺序
 - && 与，先求左侧，左侧为真才求右侧
 - || 或; ?: 条件运算符; , 逗号运算符
 - 求值顺序与优先级和结合律无关 （p123）
 
 - 算术运算符
 - 算术运算符的运算对象和求值结果都是右值
 - c++早期版本负值的商向上或向下取整，c++11规定商一律向0取整（去除小数）
 - m%n不为0时，符号与m相同（p125）
 
 - 逻辑和关系运算符
 - && 和 || 是短路求值的，左侧运算对象可以用来确保右侧运算对象的安全性
 
 - 赋值运算符
 - 左侧是可修改的左值（不能是常量左值）
 - 运算结果是左侧的运算对象，是左值。左右两侧类型不同时，转化为左侧运算对象的类型。
 - 允许使用初始值列表初始化。
 - 服从右结合律：int ival, jval;  ival = jval = 0; //ival = (jval = 0)
 - 优先级低
 
 - 递增和递减运算符
 - 在迭代器运算时是必须的
 - 两种形式：前置、后置（求值结果是运算之前值的副本）
 - __必须作用于左值，++i返回对象本身，i++把对象原始值的副本作为右值返回__
 - 尽量使用前置版本（i++会储存原始值，造成浪费）
 
 -__一条语句中混用解引用与递增__
 - auto pbeg = v.begin(); //iterator
 - while(pbeg != v.end() && *beg >=0)
 -     cout << *pbeg++ << endl; //输出当前值并将pbeg向前移动
 
 - 后置递增算符优先级高于解引用运算符
 - 多多使用 cout << *iter++ << endl;  //(p132)
 
 - (p133)运算对象的求值顺序可能导致未定义行为，同一条表达式中使用同一个变量时可能出现。
 
 - 成员访问运算符
 - ptr->mem  等价于  (*ptr).mem //mem是成员，可以是数据成员也可以是函数成员
 - __注意，解引用（*）优先级低于点运算符（.），上一句必须加上括号__
 
 - 条件运算符
 - ? : 可以嵌套，满足右结合律（先看右边的）
 - 优先级非常低，需要套上括号
 
 - 位运算符的使用
 - unsigned long quiz1 = 0 //位集合，至少32位
 - unsigned long 1UL = 1;
 - quiz1 |= 1UL << 27; //对应位27与1按位或（置为1）
 - quiz1 &= ~(1UL << 27) //对应位27与0按位与（置为0）
 - bool status = quiz1 & (1UL << 27); //获得对应位27按位与1（获得值）
 - __IO运算符满足左结合律__
 - 优先级比算数的低，比关系的高
 
 - sizeof运算符
 - 返回表达式或类型名字所占的字节数
 - sizeof(type)
 - sizeof expr  //返回表达式结果类型的大小
 - sizeof不实际计算运算对象的值，无需提供具体对象，即使使用无效指针的解引用也可以！（p139）
 - 可以用来返回数组大小
 
 - 逗号运算符
 - 两个运算对象，从左到右依次求值（有求值次序）
 - 先求左侧表达式的值，然后丢弃结果。真正结果是右侧表达式的值。（p140）
 
 2. 类型转换
 - 隐式转换 显示转换
 - 算术转换+其他隐式类型转换（数组转指针，指针转换，转bool，转常量，类类型转换）（p144）
 - 显示转换
 - static_cast, dynamic_cast, const_cast, reinterpret_cast（p144）
 
 ###chap5
 
 - 语句
 - 复合语句（块），块不以分号作为结束
 
 - switch
 - switch(ch){
 -     case 'a':
 -         ++i;
 -         break;  //!!!
 -     case 'b':
 -         ++j;
 -         break;
 -     default:
 -         ++k;
 -         break;
 - }
 - switch 的内部变量定义
 - 不允许跨过变量的初始化语句直接跳转到该变量作用域的另一个位置！（p163）
 - 把变量定义在块内，让之后的case都在此变量的作用域以外。
 
 - for
 - 当不写条件，等价于true，一直循环
 
 - 范围for语句
 - for(declaration : expression)
 -     statement
 - 实现基于v.end()方法，所以不能通过范围for增加元素，会导致预存的元素个数失效(p169)
 
 - 跳转语句
 - break, continue, goto, return
 - break: 终止离他最近的while，do while，for，switch语句，继续执行这些语句后的第一条
 - continue：终止最近循环中的当前迭代并立即开始下一次迭代（p171） __continue in switch case?__
 - 不要用goto
 
 - __try语句块和异常处理__(p173)
 - throw表达式：引发异常
 - try语句块：try块中抛出的异常由多个catch子句处理
 - 一套异常类（标准异常p176）
 
 ###chap6
 1. 函数
 - 函数定义：返回类型，函数名字，形参列表，函数体
 - 调用运算符（一对括号）作用于一个表达式（函数或指向函数的指针），括号内是实参
 
 - 函数的调用完成两项工作：用实参初始化函数对应的形参，将控制权转移给被调函数（主调函数的执行暂时中断，被调函数开始执行）
 - 函数执行的第一步是（隐式的）定义并初始化形参
 - 遇到return语句也完成两项工作：返回return的值，将控制权转移回主调函数
 
 - 返回类型不能是数组类型或函数类型（但是可以返回指向他们的指针）
 
 - 局部对象（形参和在函数体内部定义的变量）
 - 名字有作用域（名字可见的文本区域），对象有生命周期（程序执行时对象存在的时间）
 - 函数体之外定义的对象从程序执行开始一直存在到程序结束
 - 自动对象（只存在于块执行期间的对象）（如形参）
 - 局部静态对象（执行时初始化，一直存在到程序就结束）（static）
 
 - 函数声明
 - 类似其他名字，必须在使用前声明。只能定义一次，可以声明多次（例外：p535 15.3虚函数）
 - 在头文件中进行函数声明，在源文件中定义
 
 - 分离式编译
 - 程序编写时按照逻辑划分，每个文件独立编译（p187）
 
 - 参数传递
 - 每次调用函数，重新创建形参，并使用实参初始化。（初始化机理同变量初始化）
 - 形参是引用，将绑定到对应实参（引用传递），否则拷贝实参的值赋给形参（值传递）。
 - 使用引用避免拷贝，如果不改动值，最好声明为常量引用（const int &val）
 - 使用引用形参返回更多信息（p189）
 
 - const形参和实参
 - （顶层const：对象本身不能改）用实参初始化形参会忽略顶层const，即形参的顶层const被忽略，形参有顶层const，可以传（非）常量对象；
 - （p191）形参表里的顶层const被忽略（无法重载）
 
 - 尽量使用常量引用作为形参（__会限制函数所能接受的实参类型：不能把const，字面值或需要类型转换的对象传给普通引用形参__）（p192）
 
 - 数组形参（p193）
 
 - main:处理命令行选项（int argc， char *argv[]）
 - 向函数传递数组
 - argv[0] 为程序名字，不是用户输入
 
 - 含有可变形参的函数
 - 两种方法：所有实参类型相同，传递一个initializer_list；如果不同，写可变参数模板（p197，p618）（省略符形参p199）
 - initiaizer_list 标准库类型
 
 - return
 - 值是如何被返回的（p201）
 - 可以使用列表初始化返回值(p203)
 
 - 返回数组指针（p205）
 - __使用尾置返回类型__
 - auto func(int i) -> int(*)[10];
 
 - 
 
 
 



 
