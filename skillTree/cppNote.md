> for C++ Primer 5
# Part 1
## Chap 1 ~ 7
### chap1
1. iostream cin cout cerr clog (p5
- cin >> v1;
- cout << v1;
- std::endl 操纵符，结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。

2. 读入数量不定的数据 (p13
- while(std::cin >> value)
- 持续获取直到遇到文件结束符或出错

3. include指令  （p19
- 包含标准库时使用 < >
- 包含其他库使用 “ ”

4. 文件重定向  （p19
- __blank__

### chap2
- python, smalltalk 运行时检查数据类型 （动态
- c++编译时检查数据类型 （静态数据类型语言

1. 内置类型选择 （p32
- 明确知道不为负，使用unsigned；
- 超过int 选long long
- 算数表达式尽量不选用char或bool
- 浮点运算选用double

2. 类型转换 （p35
- 切勿混用 带符号类型 与 无符号类型

3. 字面值常量 （p35
- 20 十进制
- 024 八进制
- 0x14 十六进制

4. 转义字符 与 指定字面值类型 （p37

5. __列表初始化__ （p39
- 使用花括号来赋初始值
- 使用这种方法时，当存在丢失信息风险会报错

6. 声明与定义的关系
- 分离式编译：将程序分割为多个文件，每个文件可以被独立编译

- 声明：使得 名字 为程序所知
- extern int i;  
- 一旦显示初始化，声明即为定义： 
- extern double pi = 3.1416;
- 函数体内部，不能初始化一个extern关键字的变量 （发生重复定义

- 定义：创建与名字关联的实体
- int j;

7. 标识符 （p42
- 必须以字母或下划线开头
- 不能连续两个下划线，不能下划线+大写字母开头，函数体外标识符不能以下划线开头；

- 规范
- 变量用小写
- 自定义类名用大写开头
- 匈牙利命名法

8. 作用域
- { }花括号
- 作用域嵌套：内层作用域里可使用同名局部变量覆盖全局变量（不推荐

9. 复合类型 （p45
- 基于其他类型的定义的类型（指针与引用） 基本数据类型 + 声明符列表， 每个声明符命名变量并指定相关类型

 9.1. __引用__（左值引用）
 - int &ref = val;  //引用即别名
 - 引用本身不是对象， 不能定义引用的引用
 
 9.2. __指针__
 - 指针是一个对象，允许赋值与拷贝，
 - 指针类型要匹配
 - 预处理器（p49） NULL是预处理变量
 - _void *指针_ ：可用于存放任意对象的值，存放一个地址，但不能直接操作所指对象。
 
 9.3. _指向指针的指针 指向指针的引用_
 - int **ppi = &pi;
 - int i = 43;
 - int *p;
 - int *&r = p;  //r是一个对指针p的引用！
 - __注意！要理解r的类型，从右向左阅读r的定义。离变量名最近的符号对变量名有最直接的影响：&---r是一个引用，*---r引用的是指针，int---r引用的是int类型的指针。__
 
10. const限定符
- 为了防止对变量的更改。
- __必须初始化__   默认状态下，const对象仅在文件内有效，想在文件之间共享const对象，必须在前面添加extern关键字
 10.1. const的引用（常量引用）
 - const int ci = 1024;
 - const int &r1 = ci;  //保持常量的属性：不许赋值
 
 __初始化与const的引用（p55__
 - int i = 42;
 - const int &r1 = i; //正确的，常量引用可以绑定普通对象
 - __const int &r2 = 42 //正确的，可以绑定字面常量！！！！但是普通的引用不可以绑定字面常量__
 - __const int &r3 = r1 * 2; //正确的，可以绑定一般表达式！！！__
 
 - __常量引用的绑定原理__
 - 当发现绑定需要进行类型转换时，编译器生成临时量，让常量引用绑定 __临时量对象__ 。
 
 10.2 指针与const
 - 指向常量的指针：（pointer to const）
 - const double pi = 3.1416;  //const pi
 - const double *cptr = &pi; //指向常量的指针cptr，不允许通过此指针修改常量的值，也可以指向非常量对象
 
 - const指针(常量指针)，指针本身是常量，指针本身的值不变，指向不改变
 - int errNumb = 0;
 - int *const curErr = & errNumb; //curErr将一直指向errNumb
 - __技巧，从右向左阅读，离得最近的是const---本身是常量对象，*---是一个常量指针，int---指向int对象__
 
 10.3. 顶层 const
 - 顶层const： 指针本身是常量， 或任意对象是常量
 - 底层const： 指针对象是常量
 - const int &r = ci; //用于声明引用的const都是底层const
 
 10.4. constexpr 常量表达式
 - 值不会改变，在编译过程中就能得到计算结果的表达式。
 - const int i = 20;  //const val
 - const int constexp = i + 1; //const expr 用常量初始化的const对象
 - const int sz = get_size();  //不是常量表达式，只有在运行时才能知道结果
 - __constexpr变量__
 - 将变量声明为constexpr来验证变量的值是否为常量表达式 1）变量一定是常量 2）必须用常量初始化（或使用constexpr函数初始化）
 - （p59）字面值常量
 - constexpr int *q = nullptr;  //q是常量指针！ constexpr是顶层const 指向不改变（p60）
 
 11. 处理类型
 - typedef double wages; //wages 是 double的同义词
 - typedef wages base, *p; //base 是double的同义词， p是double*的同义词
 
 - using SI = Sales_item; //SI是Sales_item的同义词
 -__(p61) 别名指代复合类型，特别注意__
 
 - auto类型声明 
 - 一条语句只能有一个数据类型
 - const保留的性质（p62）
 - decltype 类型指示符，编译器分析类型，并不实际调用（p62）
 - decltype(f()) sum = x;   
 - __decltype()对引用的返回值记得带上引用__ (p63) 解引用操作得到引用类型，双层括号得到引用
 
 12. struct
 - struct定义最后加上分号，因为类体后面可以紧跟变量名定义对象
 
 - 一般在头文件中定义类，不要在函数体里定义类
 - 头文件中包含只能被定义一次的实体：类  const  constexpr等
 - 使用头文件保护符防止重复包含：
 - #ifndef XXX_XXX
 - #define XXX_XXX     <-预处理变量 大写 唯一
 - /*..........*/
 - #endif
 
 ###chap3
 1.using
 - using std::cin;  //using声明，可以直接使用名字cin
 - 头文件中的代码一般不适用using，重复拷贝后，可能产生名字冲突
 
 2. string
 - #include <string>
 - using std::string;
 
 - string s4(n, 'c'); //s4初始化为连续n个c的字符串
 - 直接初始化和拷贝初始化（用“=”）
 
 - 操作
 - getline(is, s) //从is中读一行赋给s
 - s[1] + s[2] //连接
 - <, <=, >, >= //利用字典顺序比较，大小写敏感
 
 - string::size_type //size()方法返回类型，无符号整型（p79）
 
 - 字面值与string相加，不能两个字面值相加
 
 - 字符处理 cctype头文件（p82）
 
 - __基于范围的for语句__
 - for(atuo c : str){ /*....*/ } //c的类型是char
 - for(auto &c : s){ /*....*/ } //这里是引用，会改变s中字符的值
 
 3. vector
 - 容器（part2）
 - #include <vector>
 - using std::vector;
 
 - 类模板，实例化
 
 - 定义和初始化：（p87）
 - vector<T> v2(v1)； //拷贝v1的元素给v2
 - vector<T> v3(n, val); //
 - vector<T> v4(n); //
 - vector<T> v5{a, b, c...}; //(p89) 列表初始化 提供的值不能作为元素初始值时，尝试默认初始化
 
 - vector操作（p91）
 4. 迭代器（iterator）
 - 类似指针，提供对对象的间接访问，分为有效无效，有效迭代器指向某个元素或指向尾元素的下一位置；其他是无效。
 
 - auto b = v.begin(), e = v.end(); //b,e类型相同
 - begin成员返回指向第一个元素的迭代器，end成员返回指向容器“尾元素下一位置”的迭代器（“尾后元素“），标记表示已经处理完了容器中的所有元素（尾后迭代器），当容器为空，b和e返回同一个迭代器。
 
 - 迭代器操作（p96）
 - *iter, iter->mem, ++iter, --iter
 - 迭代器运算符==，!=判断迭代器是否相等
 
 - 迭代器类型 分为 iterator和const_iterator，类似指针和常量指针；
 - cbegin(),cend()
 - __箭头运算符”->“也可以访问成员函数__（解引用+成员访问）
 - 迭代器失效！使用迭代器的循环体不要向容器中添加元素！
 
 - 迭代器运算（p99）
 - iter + n, iter += n, iter1 - iter2, <=
 
 5. 数组
 - __编译时维度必须已知，必须是常量表达式（constexpr）__
 - 字符数组初始化时，需要考虑'\0'的位置，使用字符串初始化字符数组，会自动添加\0,列表初始化需要手动添加。
 
 - __复杂的数组声明__
 - int *ptrs[10]; //ptrs是含有10个整形指针的数组
 - int &refs[10]; //错误！不存在引用的数组
 - int (*Parray)[10]; //Parray指向一个含有10个整数的数组
 - int (&arrRef)[10]; //引用一个含有10个元素的数组
 - 从数组名字开始 由内向外阅读
 
 - （p105）auto 和 decltype使用数组名作为参数的情况
 
 - 获取尾后指针可以暂时越界访问数组，更应该使用c++11的begin和end函数
 
 - （p108）下标和指针的转换
 
 - c风格字符串（字符数组+\0结尾，利用指针操作）
 - c标准库string函数（p109）
 
 - （p111）使用string对象初始化指向字符数组的指针 c_str()方法
 - 使用数组初始化vector（使用begin和end）
 
 ###chap4
 1. 表达式基础
 - 运算对象提升（p141）
 - 左值右值：用对象的值（内容）——右值，用对象的身份（内存中的位置）——左值
 - 需要右值的地方可以用左值代替，但是不能用右值当成左值。
 - 需要左值：
 - 赋值运算符，左侧左值，得到左值
 - 取值运算符，作用于左值，返回一个指向其的指针，此指针是右值
 - 解引用，下标运算符，求值结果为左值
 - __递增递减运算符，作用于左值，前置版本得到左值__
 - decltype()中的表达式求值是左值，得到引用类型，是右值得到指针（p121）
 
 - 求值顺序
 - && 与，先求左侧，左侧为真才求右侧
 - || 或; ?: 条件运算符; , 逗号运算符
 - 求值顺序与优先级和结合律无关 （p123）
 
 - 算术运算符
 - 算术运算符的运算对象和求值结果都是右值
 - c++早期版本负值的商向上或向下取整，c++11规定商一律向0取整（去除小数）
 - m%n不为0时，符号与m相同（p125）
 
 - 逻辑和关系运算符
 - && 和 || 是短路求值的，左侧运算对象可以用来确保右侧运算对象的安全性
 
 - 赋值运算符
 - 左侧是可修改的左值（不能是常量左值）
 - 运算结果是左侧的运算对象，是左值。左右两侧类型不同时，转化为左侧运算对象的类型。
 - 允许使用初始值列表初始化。
 - 服从右结合律：int ival, jval;  ival = jval = 0; //ival = (jval = 0)
 - 优先级低
 
 - 递增和递减运算符
 - 在迭代器运算时是必须的
 - 两种形式：前置、后置（求值结果是运算之前值的副本）
 - __必须作用于左值，++i返回对象本身，i++把对象原始值的副本作为右值返回__
 - 尽量使用前置版本（i++会储存原始值，造成浪费）
 
 -__一条语句中混用解引用与递增__
 - auto pbeg = v.begin(); //iterator
 - while(pbeg != v.end() && *beg >=0)
 -     cout << *pbeg++ << endl; //输出当前值并将pbeg向前移动
 
 - 后置递增算符优先级高于解引用运算符
 - 多多使用 cout << *iter++ << endl;  //(p132)
 
 - (p133)运算对象的求值顺序可能导致未定义行为，同一条表达式中使用同一个变量时可能出现。
 
 - 成员访问运算符
 - ptr->mem  等价于  (*ptr).mem //mem是成员，可以是数据成员也可以是函数成员
 - __注意，解引用（*）优先级低于点运算符（.），上一句必须加上括号__
 
 - 条件运算符
 - ? : 可以嵌套，满足右结合律（先看右边的）
 - 优先级非常低，需要套上括号
 
 - 位运算符的使用
 - unsigned long quiz1 = 0 //位集合，至少32位
 - unsigned long 1UL = 1;
 - quiz1 |= 1UL << 27; //对应位27与1按位或（置为1）
 - quiz1 &= ~(1UL << 27) //对应位27与0按位与（置为0）
 - bool status = quiz1 & (1UL << 27); //获得对应位27按位与1（获得值）
 - __IO运算符满足左结合律__
 - 优先级比算数的低，比关系的高
 
 - sizeof运算符
 - 返回表达式或类型名字所占的字节数
 - sizeof(type)
 - sizeof expr  //返回表达式结果类型的大小
 - sizeof不实际计算运算对象的值，无需提供具体对象，即使使用无效指针的解引用也可以！（p139）
 - 可以用来返回数组大小
 
 - 逗号运算符
 - 两个运算对象，从左到右依次求值（有求值次序）
 - 先求左侧表达式的值，然后丢弃结果。真正结果是右侧表达式的值。（p140）
 
 2. 类型转换
 - 隐式转换 显示转换
 - 算术转换+其他隐式类型转换（数组转指针，指针转换，转bool，转常量，类类型转换）（p144）
 - 显示转换
 - static_cast, dynamic_cast, const_cast, reinterpret_cast（p144）
 
 ###chap5
 
 
 
 
 
 



 
